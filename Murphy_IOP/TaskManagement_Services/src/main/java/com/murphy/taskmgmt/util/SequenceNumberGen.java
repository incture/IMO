package com.murphy.taskmgmt.util;



import org.hibernate.Criteria;
import org.hibernate.Session;
import org.hibernate.criterion.Restrictions;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import com.murphy.taskmgmt.dao.OffsetFracPackDao;
import com.murphy.taskmgmt.entity.SeqNumberDo;
import com.murphy.taskmgmt.service.interfaces.SequenceNumberGenLocal;



@Service
public class SequenceNumberGen implements SequenceNumberGenLocal{

	SeqNumberDo sequenceNumbersDo = null;
	private static int oldRunningNumber = 0;
	private static String oldRefCode = "";

	@Autowired
	OffsetFracPackDao offsetFracPackDao;
	
	/*public SequenceNumberGen() {
	}

	public static synchronized SequenceNumberGen getInstance() {
		return sequenceNumberGenerator == null ? sequenceNumberGenerator = new SequenceNumberGen()
				: sequenceNumberGenerator;
	}*/

	/**
	 * Generates a code in CCCCXXYYYYMMNNNN format, where CCCC is Company Code,
	 * XX is Transaction Type, YYYY is year, MM is Month, NNNN is the number
	 * generated by this function. Input field <code>referenceCode</code> is
	 * CCCCXXYYYYMM and <code>noOfDigits</code> indicate size of NNNN. Function
	 * uses a variable of hash map data structure with application scope, where
	 * referenceCode parameter is the key and running number(sequential,
	 * incremented by 1, starting from 0) is the value. Function is thread-safe,
	 * map variable is lazy loaded once, and value persist to relevant table in
	 * CEDB on every request.
	 */
	public  String getNextSeqNumber(String referenceCode, Integer noOfDigits) {
		
		System.err.println("inside getNextSeqNumber() ");
		
		Session session = offsetFracPackDao.getSession();
		
		Criteria criteria = session.createCriteria(SeqNumberDo.class);
		criteria.add(Restrictions.eq("referenceCode", referenceCode));

		sequenceNumbersDo = (SeqNumberDo) criteria.uniqueResult();

		int runningNumber;
		if (sequenceNumbersDo != null) {

			session.refresh(sequenceNumbersDo);
			runningNumber = updateRecord(sequenceNumbersDo, session);
			if (oldRunningNumber == runningNumber && oldRefCode.equals(referenceCode)) {// to
																						// avoid
																						// duplicates
				Criteria criteria1 = session.createCriteria(SeqNumberDo.class);
				criteria1.add(Restrictions.eq("referenceCode", referenceCode));

				sequenceNumbersDo = (SeqNumberDo) criteria1.uniqueResult();
				runningNumber = updateRecord(sequenceNumbersDo, session);
			}
		} else {
			runningNumber = pushRecord(referenceCode, session);
		}
		oldRunningNumber = runningNumber;
		oldRefCode = referenceCode;
		return buildSeqNumber(referenceCode, noOfDigits, runningNumber);
	}

	private String buildSeqNumber(String referenceCode, Integer noOfDigits, int runningNumber) {
		StringBuffer sb = new StringBuffer(noOfDigits);
		sb.append(runningNumber);
		int noOfPads = noOfDigits - sb.length();
		// TODO: decide what to do if noOfPads is negative
		while (noOfPads-- > 0) {
			sb.insert(0, '0');
		}
		sb.insert(0, referenceCode);
		return sb.toString();
	}

	private int pushRecord(String referenceCode, Session session) {
		SeqNumberDo sequenceNumbersDo = new SeqNumberDo(referenceCode, 1);
		// NOTE: Hard coding to zero
		session.persist(sequenceNumbersDo);
		return sequenceNumbersDo.getRunningNumber();
	}

	private int updateRecord(SeqNumberDo sequenceNumbersDo, Session session) {
		int runningnumber = 0;
		sequenceNumbersDo.setRunningNumber(sequenceNumbersDo.getRunningNumber() + 1);

		session.persist(sequenceNumbersDo);
		session.flush();
		session.refresh(sequenceNumbersDo);
		Criteria criteria = session.createCriteria(SeqNumberDo.class);
		criteria.add(Restrictions.eq("referenceCode", sequenceNumbersDo.getReferenceCode()));

		SeqNumberDo retDto1 = (SeqNumberDo) criteria.uniqueResult();

		if (retDto1 != null) {
			runningnumber = retDto1.getRunningNumber();
		}

		return runningnumber;
	}
}